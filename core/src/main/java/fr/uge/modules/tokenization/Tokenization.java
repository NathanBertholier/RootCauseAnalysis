package fr.uge.modules.tokenization;

import fr.uge.modules.api.model.entities.LogEntity;
import fr.uge.modules.api.model.entities.TokenEntity;
import fr.uge.modules.linking.token.type.*;

import java.sql.Timestamp;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Tokenization {
    private static final Logger LOGGER = Logger.getGlobal();
    private final List<TokenType> tokenTypes = new ArrayList<>();
    private final TypeTime time = new TypeTime();
    private final TypeDate date = new TypeDate();
    private final TypeHTTPStatus httpstatus = new TypeHTTPStatus();
    private final SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    public Tokenization() {
        tokenTypes.add(new TypeIPv4());
        tokenTypes.add(new TypeIPv6());
        tokenTypes.add(new TypeEdgeResponse());
    }

    public LogEntity tokenizeLog(long id, String body) {
        Objects.requireNonNull(body);
        // Containing the token values
        List<TokenEntity> tokens = new ArrayList<>();

        String[] words = body.split("\t");
        String dateString = "";
        String timeString = "";

        if(words.length > 8){
            var httpToken = this.parseHTTPStatus(words[8]);
            if(httpToken.isEmpty()){
                tokenTypes.add(httpstatus);
            } else {
                tokens.add(httpToken.get());
            }
        } else {
            tokenTypes.add(httpstatus);
        }

        for (String word : words) {
            if(date.matcher(word) != -1) {
                dateString = word;
            } else if(time.matcher(word) != -1) {
                timeString = word;
            } else {
                this.parseTokens(tokens, word);
            }
        }

        var log = new LogEntity();
        log.setId(id);
        try {
            Timestamp timestamp = new Timestamp(this.formatter.parse(dateString + " " + timeString).getTime());
            log.setDatetime( timestamp );
            log.setAutogeneratedDatetime( false );
        }
        catch (ParseException e) {
            LOGGER.log(Level.WARNING, "Incorrect timestamp ",e);
            log.setDatetime( Timestamp.from(Instant.now()) );
            log.setAutogeneratedDatetime( true );
        }
        log.setTokens(tokens);
        System.out.println("Tokenizer: " + log);
        return log;
    }

    private void parseTokens(List<TokenEntity> tokenEntities, String word) {
        for(TokenType tokenType: tokenTypes){
            var type = tokenType.matcher(word);
            if(type != -1){
                TokenEntity token = new TokenEntity();
                token.setIdtokentype(type);
                token.setValue(word);
                tokenEntities.add(token);
                if (type == 3){
                    tokenTypes.remove(httpstatus);
                    break;
                }
            }
        }
    }

    private Optional<TokenEntity> parseHTTPStatus(String word) {
        var type = httpstatus.matcher(word);
        if(type != -1){
            TokenEntity token = new TokenEntity();
            token.setIdtokentype(type);
            token.setValue(word);
            return Optional.of(token);
        } else {
            return Optional.empty();
        }
    }
}
