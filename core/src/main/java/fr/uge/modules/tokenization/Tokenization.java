package fr.uge.modules.tokenization;

import fr.uge.modules.api.model.entities.LogEntity;
import fr.uge.modules.api.model.entities.TokenEntity;
import fr.uge.modules.linking.token.type.TokenType;
import fr.uge.modules.tokenization.configuration.AWSProfile;
import fr.uge.modules.tokenization.configuration.Profile;
import fr.uge.modules.tokenization.configuration.StandardProfile;
import io.quarkus.runtime.StartupEvent;
import org.eclipse.microprofile.config.ConfigProvider;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;

@ApplicationScoped
public class Tokenization {
    private Profile profile = new AWSProfile();

    /**
     * Construct the profile at start using quarkus variable.
     */
    public void chooseProfile(@Observes StartupEvent ev) {
        this.profile = switch (ConfigProvider.getConfig()
                .getOptionalValue("profile.name", String.class)
                .orElse("AWS")) {
            case "standard" -> new StandardProfile();
            default -> new AWSProfile();
        };
    }

    /**
     * Tokenize a log using the profile, his id and a body.
     * The tokenization takes place in 3 steps :
     *      - split the body as words
     *      - search for the timestamp or set the current time
     *      - search for each token using the profile
     *
     * @param id    Represent the ID of the rawLog
     * @param body  Represent the body of a log
     * @return      A LogEntity construct with the ID and each token
     */
    public LogEntity tokenizeLog(long id, String body) {
        Objects.requireNonNull(body);

        var words = Arrays.asList(body.split("\t|[ ]+"));
        var log = new LogEntity();

        var timeStamp = profile.getTimestamp(words);
        if(timeStamp.isEmpty()) {
            log.setDatetime(Timestamp.from(Instant.now()));
            log.setAutogeneratedDatetime(true);
        } else {
            log.setDatetime(timeStamp.get());
            log.setAutogeneratedDatetime(false);
        }

        log.setId(id);
        log.setTokens(this.getTokens(words));
        return log;
    }


    /**
     * Method called for search each token.
     * It takes place in 3 steps :
     *      - Retrieve each token saved in the profile.
     *      - Get all tokens using the index of the profile and add the tokenType in a list if the token was not found
     *      - Iterate over each word and call each tokenType matcher on them
     *
     * @param words List of String that represent the body
     * @return      A List of TokenEntity used in the LogEntity
     */
    private List<TokenEntity> getTokens(List<String> words) {
        List<TokenType> tokenTypesNoFound = new ArrayList<>();

        List<TokenEntity> tokens = new ArrayList<>(profile.getTokenTypeIndex().entrySet().stream()
                .map(k -> {
                    var token = getTokenWithIndex(k.getValue(), k.getKey(), words);
                    if (token.isEmpty()) {
                        tokenTypesNoFound.add(k.getKey());
                    }
                    return token;
                })
                .filter(Optional::isPresent)
                .map(Optional::get)
                .toList());

        tokenTypesNoFound.addAll(profile.getTokenType());

        words.forEach(word -> tokenTypesNoFound.stream()
                .filter(tokenType -> tokenType.matcher(word) != -1)
                .forEach(tokenType -> {
                    TokenEntity token = new TokenEntity();
                    token.setIdtokentype(tokenType.getTokenTypeId());
                    token.setValue(word);
                    tokens.add(token);
                }));

        return Collections.unmodifiableList(tokens);
    }

    /**
     * Retrieve a token from the index.
     * @param index     Integer that represent the position of the token
     * @param tokenType The Token TokenType
     * @param words     List of String that represent the log
     * @return          Optional of TokenEntity, Empty if none
     */
    private Optional<TokenEntity> getTokenWithIndex(Integer index, TokenType tokenType, List<String> words) {
        var token = new TokenEntity();
        if(index < words.size() - 1 && tokenType.matcher(words.get(index)) != -1) {
            token.setIdtokentype(tokenType.getTokenTypeId());
            token.setValue(words.get(index));
            return Optional.of(token);
        }
        return Optional.empty();
    }
}
