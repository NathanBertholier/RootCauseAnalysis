package fr.uge.modules.tokenization;

import fr.uge.modules.api.model.entities.LogEntity;
import fr.uge.modules.api.model.entities.TokenEntity;
import fr.uge.modules.linking.token.type.TokenType;
import fr.uge.modules.tokenization.configuration.Profile;
import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.inject.Named;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;
import java.util.logging.Logger;

@ApplicationScoped
public class Tokenization {
    private static final Logger LOGGER = Logger.getGlobal();

    @Named("AWS")
    @Inject
    Profile profile;

    public LogEntity tokenizeLog(long id, String body) {
        Objects.requireNonNull(body);

        var words = Arrays.asList(body.split("\t|[ ]+"));
        var log = new LogEntity();

        var timeStamp = profile.getTimestamp(words);
        if(timeStamp.isEmpty()) {
            log.setDatetime(Timestamp.from(Instant.now()));
            log.setAutogeneratedDatetime(true);
        } else {
            log.setDatetime(timeStamp.get());
            log.setAutogeneratedDatetime(false);
        }

        log.setId(id);
        log.setTokens(List.copyOf(this.getTokens(words)));
        return log;
    }

    private Optional<TokenEntity> getTokenWithIndex(Integer index, TokenType tokenType, List<String> words) {
        var token = new TokenEntity();
        if(index > words.size()) {
            return Optional.empty();
        }
        if(tokenType.matcher(words.get(index)) == -1) {
            return Optional.empty();
        }

        token.setIdtokentype(tokenType.getTokenTypeId());
        token.setValue(words.get(index));
        return Optional.of(token);
    }

    public List<TokenEntity> getTokens(List<String> words) {
        List<TokenType> tokenTypesNoFound = new ArrayList<>();

        List<TokenEntity> tokens = new ArrayList<>(List.copyOf(profile.getTokenTypeIndex().entrySet().stream().map((k) -> {
            var token = getTokenWithIndex(k.getValue(), k.getKey(), words);
            if (token.isEmpty()) {
                tokenTypesNoFound.add(k.getKey());
            }
            return token;
        }).filter(Optional::isPresent).map(Optional::get).toList()));

        tokenTypesNoFound.addAll(profile.getTokenType());

        words.forEach(word -> tokenTypesNoFound.stream()
                .filter(tokenType -> tokenType.matcher(word) != -1)
                .forEach(tokenType -> {
                    TokenEntity token = new TokenEntity();
                    token.setIdtokentype(tokenType.getTokenTypeId());
                    token.setValue(word);
                    tokens.add(token);
                }));

        return tokens;
    }
}
