package fr.uge.modules.tokenization;

import fr.uge.modules.api.model.entities.LogEntity;
import fr.uge.modules.api.model.entities.TokenEntity;
import fr.uge.modules.linking.token.type.TokenType;
import fr.uge.modules.tokenization.configuration.AWSProfile;
import fr.uge.modules.tokenization.configuration.Profile;
import fr.uge.modules.tokenization.configuration.StandardProfile;
import io.quarkus.runtime.StartupEvent;
import org.eclipse.microprofile.config.ConfigProvider;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.event.Observes;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.*;
import java.util.logging.Logger;

@ApplicationScoped
public class Tokenization {
    private static final Logger LOGGER = Logger.getGlobal();

    private Profile profile= new AWSProfile();

    public void chooseProfile(@Observes StartupEvent ev) {
        this.profile = switch (ConfigProvider.getConfig()
                .getOptionalValue("profile.name", String.class)
                .orElse("standard")) {
            case "AWS" -> new AWSProfile();
            default -> new StandardProfile();
        };
    }

    public LogEntity tokenizeLog(long id, String body) {
        Objects.requireNonNull(body);

        var words = Arrays.asList(body.split("\t|[ ]+"));
        var log = new LogEntity();

        var timeStamp = profile.getTimestamp(words);
        if(timeStamp.isEmpty()) {
            log.setDatetime(Timestamp.from(Instant.now()));
            log.setAutogeneratedDatetime(true);
        } else {
            log.setDatetime(timeStamp.get());
            log.setAutogeneratedDatetime(false);
        }

        log.setId(id);
        log.setTokens(List.copyOf(this.getTokens(words)));
        return log;
    }

    private Optional<TokenEntity> getTokenWithIndex(Integer index, TokenType tokenType, List<String> words) {
        var token = new TokenEntity();
        if(index < words.size() - 1 && tokenType.matcher(words.get(index)) != -1) {
            token.setIdtokentype(tokenType.getTokenTypeId());
            token.setValue(words.get(index));
            return Optional.of(token);
        }
        return Optional.empty();
    }

    public List<TokenEntity> getTokens(List<String> words) {
        List<TokenType> tokenTypesNoFound = new ArrayList<>();

        List<TokenEntity> tokens = new ArrayList<>(List.copyOf(profile.getTokenTypeIndex().entrySet().stream().map((k) -> {
            var token = getTokenWithIndex(k.getValue(), k.getKey(), words);
            if (token.isEmpty()) {
                tokenTypesNoFound.add(k.getKey());
            }
            return token;
        }).filter(Optional::isPresent)
                .map(Optional::get)
                .toList()));

        tokenTypesNoFound.addAll(profile.getTokenType());

        words.forEach(word -> tokenTypesNoFound.stream()
                .filter(tokenType -> tokenType.matcher(word) != -1)
                .forEach(tokenType -> {
                    TokenEntity token = new TokenEntity();
                    token.setIdtokentype(tokenType.getTokenTypeId());
                    token.setValue(word);
                    tokens.add(token);
                }));

        return tokens;
    }
}
